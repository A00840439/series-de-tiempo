# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_PQDlz-F5usUfEB1kHueDWJd295DuzSI
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
import warnings
warnings.filterwarnings("ignore")

# Define tickers and date range
tickers = ['KO', 'MCD', 'MSFT']
start_date = '2019-11-29'
end_date = '2025-04-11'

# Download adjusted close prices
data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']
returns = data.pct_change().dropna()

# 1. Random Walk Simulation
def random_walk_simulation(price_series, steps):
    np.random.seed(42)
    shocks = np.random.normal(0, price_series.std(), steps)
    rw = price_series.iloc[0] + np.cumsum(shocks)
    return pd.Series(rw, index=price_series.index[:len(rw)])

# Simulate random walks
rw_simulations = {ticker: random_walk_simulation(data[ticker], len(data)) for ticker in tickers}

# Plot actual prices vs random walk
plt.figure(figsize=(12, 8))
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 1, i)
    plt.plot(data[ticker], label=f'{ticker} Actual', color='blue')
    plt.plot(rw_simulations[ticker], label=f'{ticker} Random Walk', linestyle='--', color='orange')
    plt.title(f'{ticker} Price vs Random Walk')
    plt.legend()
    plt.grid(True)
plt.tight_layout()
plt.show()

# 2. Unit Root Test (ADF)
def adf_test(series, ticker):
    result = adfuller(series, autolag='AIC')
    print(f'\n{ticker} ADF Test Results:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    return result[1]

adf_results = {ticker: adf_test(data[ticker], ticker) for ticker in tickers}

# 3. Cointegration Test
def cointegration_test(series1, series2, ticker1, ticker2):
    score, p_value, _ = coint(series1, series2)
    print(f'\nCointegration Test: {ticker1} vs {ticker2}')
    print(f'Test Statistic: {score:.4f}')
    print(f'p-value: {p_value:.4f}')
    return p_value

# Test cointegration for all pairs
pairs = [('KO', 'MCD'), ('KO', 'MSFT'), ('MCD', 'MSFT')]
coint_results = {f'{t1}-{t2}': cointegration_test(data[t1], data[t2], t1, t2) for t1, t2 in pairs}

# Plot equity curves (cumulative returns)
plt.figure(figsize=(12, 6))
cum_returns = (1 + returns).cumprod()
for ticker in tickers:
    plt.plot(cum_returns[ticker], label=ticker)
plt.title('Cumulative Returns (Equity Curves)')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.grid(True)
plt.show()

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
import warnings
warnings.filterwarnings("ignore")

# Define tickers and date range
tickers = ['KO', 'MCD', 'MSFT', 'BA']
start_date = '2019-11-29'
end_date = '2025-04-11'

# Download close prices (auto_adjust=True by default, so use 'Close')
data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)['Close']
returns = data.pct_change().dropna()

# 1. Random Walk Simulation
def random_walk_simulation(price_series, steps):
    np.random.seed(42)
    shocks = np.random.normal(0, price_series.std(), steps)
    rw = price_series.iloc[0] + np.cumsum(shocks)
    return pd.Series(rw, index=price_series.index[:len(rw)])

# Simulate random walks
rw_simulations = {ticker: random_walk_simulation(data[ticker], len(data)) for ticker in tickers}

# Plot actual prices vs random walk
plt.figure(figsize=(12, 10))
for i, ticker in enumerate(tickers, 1):
    plt.subplot(4, 1, i)
    plt.plot(data[ticker], label=f'{ticker} Actual', color='blue')
    plt.plot(rw_simulations[ticker], label=f'{ticker} Random Walk', linestyle='--', color='orange')
    plt.title(f'{ticker} Price vs Random Walk')
    plt.legend()
    plt.grid(True)
plt.tight_layout()
plt.show()

# 2. Unit Root Test (ADF)
def adf_test(series, ticker):
    result = adfuller(series, autolag='AIC')
    print(f'\n{ticker} ADF Test Results:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    return result[1]

adf_results = {ticker: adf_test(data[ticker], ticker) for ticker in tickers}

# 3. Cointegration Test
def cointegration_test(series1, series2, ticker1, ticker2):
    score, p_value, _ = coint(series1, series2)
    print(f'\nCointegration Test: {ticker1} vs {ticker2}')
    print(f'Test Statistic: {score:.4f}')
    print(f'p-value: {p_value:.4f}')
    return p_value

# Test cointegration for select pairs
pairs = [('KO', 'MCD'), ('KO', 'MSFT'), ('KO', 'BA'), ('MCD', 'MSFT'), ('MCD', 'BA'), ('MSFT', 'BA')]
coint_results = {f'{t1}-{t2}': cointegration_test(data[t1], data[t2], t1, t2) for t1, t2 in pairs}

# Plot equity curves (cumulative returns)
plt.figure(figsize=(12, 6))
cum_returns = (1 + returns).cumprod()
for ticker in tickers:
    plt.plot(cum_returns[ticker], label=ticker)
plt.title('Cumulative Returns (Equity Curves)')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.grid(True)
plt.show()